*******************************************
	*** MISC ***
*******************************************

- Using libraries more impoartant than knowing all syntax by heart
- Standard Lib https://golang.org/pkg/

- Golang enigmatic at first
- Mechanic sympathy: uint is either uint32 or uint64, depending on underlying architecture. 

- C
 - the only non-OOO lang
 - objective C - expanded C, Apple

- JavaScript
 - OOO and C-based
 - JS usually put at the bottom of a page, browser pre-interpreting everything first.

- Java
 - C-based, there is huge Java lib..
 - compiles into Byte Code so needs JVM..
 - very OOO, everything runs in a class

- Turbo Pascal -> Delphi

- C# and VB.NET - MS

- Ruby - not C-based, no mem management, no compilers (interpreted), 
	- everything is a object, even primitives

- Python 
 - quite like Ruby - indentation important

- Go being hybrid btw OO and plain functional programming 
 - Garbage collection occurs once a function comes off the heap
 - Strictly, strongly typed
	- compiling stops on type errors 
	- prevents simple errors, dev is faster, more readable code
	- correct use of const and enums essential to make the code even stricter
 - Const, Enum, Iota
 - x += 10 //plequal


*******************************************
	*** ZERO (DEFAULT) VALUES ***
*******************************************

int         0
float       float64
bool        false
string      empty ""

pointers    nil
maps        nil
slices      nil
funcs       nil
interfaces  nil

*******************************************
	*** VERBS ***
*******************************************

https://golang.org/pkg/fmt/

Type: fmt.Printf("%T", var)


*******************************************
  *** PACKAGES ***
*******************************************

- /src, where local packages live


*******************************************
  *** FUNCTIONS ****
*******************************************

- FUNCS are VALUES
- VARS can be of TYPE FUNC
		
		add := func(a, b int) int {
			return a + b
		}

- FUNCS pass by VALUE
	- passing by value 
		a) can be expensive
		b) wont change the original value 
	- hence, use pointers

- FUNCTION CLOSURE
	- outer vs inner func
		// greeter() is the outer func, returns nothing
		// i is in outer function
		// fn then is inner function, has access to text variable: that's a closure
		// closures have access to variables even after exiting this block

		greeter(3)
		func greeter(number int) {
			i := 2 + number
			fn := func() {
			fmt.Println(i)
			}
			fn() 			// and actually calling the closure
		}	// 5

- FUNCTION CALLBACKS
 - passing in a func thats a callback
	filepath.Walk("DATA/", func(path string, info os.FileInfo, err error) error {
		if info.IsDir() {
			return nil
		}
		fmt.Println(path)
		return nil
	})

*******************************************
  *** FOR vs WHILE ***
*******************************************

- SIMPLE LOOP

  i := 10
			for ; i > 0; i-- {
				fmt.Println("IF", i)
			}

- FOREVER

  for {
  ... stuff ...
  }

- WHILE
  while n is positiv. So difference between for and while really is where
  the counter goes.

		n := 10
		for n > 0 {
			n--
			fmt.Println("WHILE:", n)
		}


*******************************************
	*** SLICES ***
*******************************************

- variadic
		sillySlices = append(sillySlices, s1...)

- remove


*******************************************
  *** MAPS ***
*******************************************

- Outside main(), initialize a global map as empty, using trailing {}
	var m = map[string]int{}

- m := make(map[string]CMember) //k: sting, v: struct

- Map is in a struct: 
  mc := MapCounter{m: make(map[int]int)}

- if key doesnt exist it is added
		m["string1"] = cm1
		m["string2"] = CMember{"Jo", 12, "Kids place", "Station Mars1", 0}

		for k, _ := range m {
			fmt.Println("k:", k)
		}

		for _, v := range m {
			fmt.Println("v:", v)
		}

- Two-value assignment tests for the existence of a key:
		v becomes value stored under key "string1" ok is a boolean

		v, ok := m["string1"]
		fmt.Println("key ok?:", v, ok) // {value of "string1"}, true

- RWMutex is more efficient than Mutex as it uses Lock only on writes, and allows several reads
  using RLock on read. Excellent for maps because maps / read writes are not threadsafe by default.


*******************************************
  *** TYPE  ***
*******************************************

- TYPE INFERENCE
		i := 10 //type i inferred to be int

- NEW TYPE

	new(T) 
  lower case new(T) allocates zeroed storage for a new item of type T
  It returns its address, a value of type *T. 
  Basically it returns a pointer to a newly allocated zero value of type T.

- TYPE SWITCHING:

	func main (){
			...
			n := createNode(5)

		switch n := n.(type) {
			case *SLLNode:
				fmt.Println("Type is SLLNode , message:", n.SNodeMessage)
			case *PowerNode:
				fmt.Println("Type is PowerNode, message:", n.PNodeMessage)
				...
	
		func createNode() {
			...
		}

- TYPE ASSERTION

	if v, ok := m.GetValue().(string); ok {//stuff} //type assertion

- CONCRETE TYPE

	Any type / struct that has methods

*******************************************
  *** STRUCTS ***
*******************************************

- structs are types

- test a method
		struct and method outside main
		so inside main
    	reflect.ValueOf(structVarName).MethodByName("methodName").Call([]reflect.Value{})

- Sets:
	  outside main:
      type set map[string]struct{} // a string map
	  inside main
		  s := make(set)

- Embedding, Composition:
  	outer type, inner type
  	outer T has access to all inner

- Promoting:
    Method with same name as in package: Priority given to local method.
    udemy-master/structs/embedding.go

*******************************************
	METHODS and INTERFACES
*******************************************

- M and I aka as classes
- M is a F, attached to a T (through the receiver).
- Object of a T that has Ms runs a M like this: f.Close() ( *not* like this Close(f) )
  In fact, receivers set the T that a method implements.
	R can be nil.
- A T then implements an I, if it has the M

- The T is usually a S.

- Interfaces are 2 things:
		collection of method signatures
		Type themselves

- Every T is a child of empty interface{}

- Type can have methods, but especially methods that “implement” a given Interface from any package.
- So a Type can implement an Interface, and implicitly so. No need to re-create an Interface.
- Only the Type needs to have the method(s) the Interface advertises.
- A Type that implements Interface Methods, is then a child of that interface.

- Test to see if an implementer <here *SLLNode> implements an interface
  <that of sllNode>

    if n, ok := sllNode.(*SLLNode); ok { // and only when ok
		  fmt.Println("Yo", n.GetValue())
	  }

- Receivers set the Type a method implements
//      Object or Class Type 		M which the O implements		return
func   (sNode *SLLNode)       	SetValue(v int) 						error {}

- Receiver of a method can be nil


*******************************************
  INTERFACES
*******************************************

- If a type is of Interface, methods can be accessed either with pointer 
  or value, if the methods receiver is value.

- Whereas if methods receiver are not an interface and are pointer,
  it must be a pointer.

- SMIFO SMIO
/* ----------------------------------------
S  Structs with relevant fields.
	
	type S struct{
		...
		}

M  Methods with struct/type as receiver. 
   For diff s/t, some method names would be equal, their code different.

	func (s S) M(t T) T {
			...magic
	}

I  Interface associated with Methods M, using M signatures as field.

	type I interface{
		M(t T) T
	}


F  Function takes I, returns I.M()

	func F(i I) i.M {
		return i.M()
	}

O  Create Objects, use them on the Function F(O)

	O := S{}
	F(O)
------------------
O  When not using a F, create Objects of type I, use Os by calling relevant methods

	var O I
	O = S{}
	O.M()
----------------------------------------*/


*******************************************
  *** PATTERN ***
*******************************************

- FACTORY PATTERN
 - Creational pattern
 - Factory method handles creating objects
                                  Type A
 - App Code --> Factory method /_ Type B
                               \  Type C
 - Code is expandable
 - Troubleshooting
 - Collaboration

 - Howto: Create package XY (under src/) 
    - file1: Interface with Methods, IOTA, and Factory func
    - file2..X: The actual concrete Types 
 - Main
    - launches the object creations by calling Factory func
    - very simple code

 - Interface - Concrete Type - Factory Function

- SINGLETON PATTERN
	- Object gets created only once then reused
	- Useful to create Loglibrary (printing to the same file)
  	DB handlers (accessing the same DB over again), etc
	- type Once: even if a function is called 10x, it's only executed once

- BUILDING PATTERN
	- Creational pattern, building complicated objects piece by piece
	- Avoids building complex constructors

*******************************************
  *** CONCURRENCY ***
*******************************************

- Concurrency !Parallelism)
    Concurrency: independently executing: I eat and I talk, one or the other
    Parallelism: simultaneous execution: I run and listen, both.

- Concurrency means there are goroutines
- which requires the memory to be sync'ed and lock'ed.
- oh, goroutines are not threads, they run on threads.
  - import sync

- SIMPLE LOCK
    type Locker interface {
          Lock() // any type that has method Lock() 
          Unlock()
    }

    - type Mutex struct {}
    - func (m *Mutex) Lock()
    - func (m *Mutex) Unlock()

  - RWMUTEX LOCK
    - used on Maps which are not threadsafe
    - not sure if this has an interface
    - but add'l methods on its type
    - type RWMutex struct{}
    - RLock()
    - RUnlock()

  - ONCE
    import "sync"

    var once sync.Once // make a var of type sync.Once

    once.Do(func() {
    ... stuff ...
    }

  - WAITGROUP
    var wg sync.WaitGroup
    wg.Add(1)
    go func(i int) {
      defer wg.Done()
      ...stuff...
      }(i)
    }
    wg.Wait() //main waits
    }


- TIMERS

type Duration struct

type Timer struct

- CHANNEL GENERATOR


*******************************************
 *** TESTING ****
*******************************************

- Test every function / method for it's different conditions 
  - 161650262

- Recap:
 - src – source files organized as packages. Write Go applications inside this directory
 - pkg – Go package objects
 - bin – executable programs

- So all self-built packages live in src/, otherwise their import won't work
 - Obviously testing occurs there.
 - Tests to check coverage expect files to be under src/
  - $ go test -cover -coverprofile=c.out
  - $ go tool cover -html=c.out -o coverage.html
- Ordinary main files that live outside src/ can of course be tested where they are
 - just dont expect cover to work there
 
- Howto
 1. Create files with _test.go appended
 2. Import golang's testing package in test file
     import "testing"
 3. Write TestFunctions like
   	func TestYourFunction(t *testing.T)
		e.g. we can then use
			t.Fatal("dialing", err)
			t.Errorf(...)
 4. Use <go test -cover> command in the correct dir

- Basic examples
../../../g3_golang/mooc-udemy-master/unittesting-mains
$ tree
|____testing1
| |____sum.go
| |____main1_test.go
| |____testing1
|____testing2
| |____sum.go
| |____main2_test.go

../../../g3_golang/src/unittesting-packages
$ tree
|____testing3
| |____my.go
| |____math
| | |____math.go
| | |____math_test.go

~/work/g3_golang/src/unittesting/testing3
$ go test -cover math/
ok      math    0.017s  coverage: 81.7% of statements

~/work/g3_golang/mooc-udemy-master/unittesting-mains
$ go test ./...
ok      ../g3_golang/mooc-udemy-master/unittesting-mains/testing1    0.015s
ok      ../g3_golang/mooc-udemy-master/unittesting-mains/testing2    0.014s

$ go test -cover -v ./...
=== RUN   TestSum
10
--- PASS: TestSum (0.00s)
PASS
coverage: 66.7% of statements
ok      ../g3_golang/mooc-udemy-master/unittesting-mains/testing1    0.015s  coverage: 66.7% of statements
=== RUN   TestSum
--- PASS: TestSum (0.00s)
PASS
coverage: 50.0% of statements
ok      ../g3_golang/mooc-udemy-master/unittesting-mains/testing2    0.014s  coverage: 50.0% of statements


- Isolation of dependencies
 - https://blog.alexellis.io/golang-writing-unit-tests/#ampshare=http://blog.alexellis.io/golang-writing-unit-tests/
 - Achieved thru interfaces
 - Interfaces are implied, rather than enforced 
   (concrete classes don't need to know about the interface ahead of time)

- Much more about Testing
 - The Go Programming Language (A. A. Donovan, Brian W. Kernighan)



*******************************************
  *** PROTOBUFS ***
*******************************************

- Consider this
  - http://www.minaandrawos.com/2014/05/27/practical-guide-protocol-buffers-protobuf-go-golang/

- data serilization
- write .proto to define data structure
- use a protobuf compiler to generate code from .proto
- generated code provides funcs and objects so to rw to data streams
- proto can be updated recompiled and redeployed 
  - dont remove existing fields
 
- protoc //the compiler //sudo apt-get install protobuf-compiler-dev
  protoc -I=$SRC_DIR --go_out=$DST_DIR $SRC_DIR/addressbook.proto
  protoc -I=$SRC_DIR --go_out=. addressbook.proto //run in dir
  http://stackoverflow.com/questions/28099004/unable-to-build-protobuf-to-go-endpoint
 
- protoc-gen-go //the go plugin //go get -u github.com/golang/protobuf/protoc

message Person {
  required string name = 1; // 1 is field ID
  required int32 id = 2;
  optional string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    required string number = 1;
    optional PhoneType type = 2 [default = HOME];
  }

  repeated PhoneNumber phone = 4; // indicates list
}


*******************************************
  *** REFLECTION ***
*******************************************

-
-




